---
alwaysApply: true
---

Project Rules (TypeScript · React · Next.js App Router · shadcn/ui · Tailwind)
0) Non-negotiables

TypeScript strict: "strict": true, no any unless justified in code with a TODO and ticket link.

ESLint + Prettier: run on save and in CI; zero lint errors; eslint-plugin-import, eslint-plugin-react-hooks, eslint-plugin-jsx-a11y, eslint-config-next, @typescript-eslint.

Conventional Commits: feat:, fix:, docs:, chore:, test:, refactor:, etc. One topic per commit.

Minimal comments: write self-documenting code; only comment to explain why, never what; prefer types & names over comments.

1) Project Structure & Naming

Use Next.js App Router (app/).

Directories:

app/ – routes, layouts, error.tsx, loading.tsx, not-found.tsx, route handlers (app/api/.../route.ts).

components/ – UI building blocks; components/ui for shadcn components only.

features/<feature>/ – feature slice (UI + hooks + models + server actions).

lib/ – framework-agnostic utilities (fetchers, parsers, formatters).

server/ – server-only helpers (db, auth, edge utilities).

hooks/, styles/, types/ (global types), config/ (app constants), tests/.

Filenames: components PascalCase.tsx; hooks useThing.ts; utilities kebab-case.ts.

Exports: named exports for libraries/components; default exports only for Next.js page/layout files.

2) React & Next.js Conventions

Server Components by default. Mark Client Components only when needed ("use client").

Data fetching: prefer server (async page/layout, or Route Handlers). Avoid fetching in useEffect.

Caching: use Next.js fetch caching ({ cache: 'force-cache' | 'no-store', next: { revalidate } }). Set revalidate on content pages.

Mutations: prefer Server Actions or /api route handlers with Zod validation.

State:

Server state → fetch on server.

Local UI state → useState/useReducer.

Global client state only when necessary (use Zustand or Context sparingly).

Navigation: use Link and useRouter from next/navigation. Avoid legacy router.

Errors/Loading: implement route-scoped error.tsx and loading.tsx. Never swallow errors.

3) Styling & UI (Tailwind + shadcn/ui)

Tailwind for all styling; no raw CSS unless a clear need. Use class-variance-authority (CVA) patterns for variants.

shadcn/ui: generate into components/ui; do not edit library files directly—wrap or extend in your own components.

Design tokens: use CSS variables and Tailwind config for colors, spacing, and typography; dark mode via class strategy.

Icons: lucide-react. Keep icon size and stroke consistent.

Accessibility: use Radix primitives properly; no div buttons; pass aria-* when needed; fix all jsx-a11y lints.

4) Forms, Validation, and Models

Forms: react-hook-form + Zod resolvers; schema per form in features/<feature>/schemas.ts.

Types: derive types from Zod (z.infer) to prevent drift. No duplicate DTO types.

Client↔Server contracts: validate both inputs and outputs on server boundaries.

5) API & Server Code

Route Handlers in app/api/.../route.ts. Return Response.json(...) with typed payloads.

Validation: Zod for request bodies, query, params; reject with proper status codes; never trust client input.

Security: never leak secrets to client; only read secrets in server files; sanitize user input; set sane CSP and headers in middleware.ts when applicable.

Auth: encapsulate in server/auth.ts; no auth logic in Client Components.

6) Performance

Use next/image and next/font; no unoptimized <img> or external font CSS.

Prefer RSC streaming and edge for low-latency reads where appropriate.

Avoid unnecessary Client Components; watch bundle size; dynamic(() => import(...)) for heavy clients.

Memoize expensive components (React.memo, useMemo, useCallback) only when profiling shows benefit.

7) Testing & Quality

Unit/Component: Vitest + @testing-library/react; file pattern *.test.ts(x).

E2E: Playwright for critical flows.

Coverage: target 80%+ overall; don’t chase 100% for trivial code.

Contracts: test zod schemas and server actions; add regression tests for all bug fixes.

8) Linting, Formatting, Imports

Enforce import/order groups: built-in, external, internal (@/*), relative.

Path alias: @/* → project root src/* (or repo root) via tsconfig.json; no deep relative ../../...

Prettier single source of formatting truth; no style overrides in editors.

9) Error Handling & Logging

Throw typed errors on server; format to JSON with code, message, optional details.

In UI, show user-friendly toasts/dialogs; never expose stack traces.

Centralize logging utilities (lib/logger.ts); no console.* in production paths.

10) Accessibility & i18n

Keyboard navigation must work; focus states visible; role and aria-* correct.

Images and icons require alt/aria-label when meaningful.

If i18n needed, use next-intl or next-i18next; no string literals in components—centralize copy.

11) Env & Config

Typed env: env.mjs with Zod; separate server and client env; access client env via NEXT_PUBLIC_*.

Feature flags/config in config/ and never in component files.

12) Git, PRs, and CI

Branch naming: type/scope-short-desc (e.g., feat/foods-parser).

PRs small and focused; include screenshots for UI changes and Playwright updates if relevant.

CI must run: typecheck, lint, tests, build. No failing PRs can be merged.

Require code review; block self-merge without at least one approval.

13) Dependencies & Tooling

Pin versions with caret; avoid unnecessary deps; prefer std libs and existing utilities.

No global polyfills unless required by Next; tree-shake friendly imports only.

Remove dead code and unused deps promptly.

14) Documentation

Keep README updated with scripts, env vars, and architecture notes (1-pager).

Co-locate feature READMEs (features/<feature>/README.md) for complex domains.

Update CHANGELOG.md on each release (auto-generated acceptable).

15) Cursor Agent Directions (meta)

Prefer Server Components and server data fetching; add "use client" only when interactivity is required.

Before writing new code, search repo for existing utilities/components.

After generating code, run eslint --fix & typecheck, add/adjust tests, and ensure accessibility lints pass.

Do not modify generated shadcn/ui primitives—wrap them.

Keep diffs minimal; avoid drive-by refactors.
Project Rules (TypeScript · React · Next.js App Router · shadcn/ui · Tailwind)
0) Non-negotiables

TypeScript strict: "strict": true, no any unless justified in code with a TODO and ticket link.

ESLint + Prettier: run on save and in CI; zero lint errors; eslint-plugin-import, eslint-plugin-react-hooks, eslint-plugin-jsx-a11y, eslint-config-next, @typescript-eslint.

Conventional Commits: feat:, fix:, docs:, chore:, test:, refactor:, etc. One topic per commit.

Minimal comments: write self-documenting code; only comment to explain why, never what; prefer types & names over comments.

1) Project Structure & Naming

Use Next.js App Router (app/).

Directories:

app/ – routes, layouts, error.tsx, loading.tsx, not-found.tsx, route handlers (app/api/.../route.ts).

components/ – UI building blocks; components/ui for shadcn components only.

features/<feature>/ – feature slice (UI + hooks + models + server actions).

lib/ – framework-agnostic utilities (fetchers, parsers, formatters).

server/ – server-only helpers (db, auth, edge utilities).

hooks/, styles/, types/ (global types), config/ (app constants), tests/.

Filenames: components PascalCase.tsx; hooks useThing.ts; utilities kebab-case.ts.

Exports: named exports for libraries/components; default exports only for Next.js page/layout files.

2) React & Next.js Conventions

Server Components by default. Mark Client Components only when needed ("use client").

Data fetching: prefer server (async page/layout, or Route Handlers). Avoid fetching in useEffect.

Caching: use Next.js fetch caching ({ cache: 'force-cache' | 'no-store', next: { revalidate } }). Set revalidate on content pages.

Mutations: prefer Server Actions or /api route handlers with Zod validation.

State:

Server state → fetch on server.

Local UI state → useState/useReducer.

Global client state only when necessary (use Zustand or Context sparingly).

Navigation: use Link and useRouter from next/navigation. Avoid legacy router.

Errors/Loading: implement route-scoped error.tsx and loading.tsx. Never swallow errors.

3) Styling & UI (Tailwind + shadcn/ui)

Tailwind for all styling; no raw CSS unless a clear need. Use class-variance-authority (CVA) patterns for variants.

shadcn/ui: generate into components/ui; do not edit library files directly—wrap or extend in your own components.

Design tokens: use CSS variables and Tailwind config for colors, spacing, and typography; dark mode via class strategy.

Icons: lucide-react. Keep icon size and stroke consistent.

Accessibility: use Radix primitives properly; no div buttons; pass aria-* when needed; fix all jsx-a11y lints.

4) Forms, Validation, and Models

Forms: react-hook-form + Zod resolvers; schema per form in features/<feature>/schemas.ts.

Types: derive types from Zod (z.infer) to prevent drift. No duplicate DTO types.

Client↔Server contracts: validate both inputs and outputs on server boundaries.

5) API & Server Code

Route Handlers in app/api/.../route.ts. Return Response.json(...) with typed payloads.

Validation: Zod for request bodies, query, params; reject with proper status codes; never trust client input.

Security: never leak secrets to client; only read secrets in server files; sanitize user input; set sane CSP and headers in middleware.ts when applicable.

Auth: encapsulate in server/auth.ts; no auth logic in Client Components.

6) Performance

Use next/image and next/font; no unoptimized <img> or external font CSS.

Prefer RSC streaming and edge for low-latency reads where appropriate.

Avoid unnecessary Client Components; watch bundle size; dynamic(() => import(...)) for heavy clients.

Memoize expensive components (React.memo, useMemo, useCallback) only when profiling shows benefit.

7) Testing & Quality

Unit/Component: Vitest + @testing-library/react; file pattern *.test.ts(x).

E2E: Playwright for critical flows.

Coverage: target 80%+ overall; don’t chase 100% for trivial code.

Contracts: test zod schemas and server actions; add regression tests for all bug fixes.

8) Linting, Formatting, Imports

Enforce import/order groups: built-in, external, internal (@/*), relative.

Path alias: @/* → project root src/* (or repo root) via tsconfig.json; no deep relative ../../...

Prettier single source of formatting truth; no style overrides in editors.

9) Error Handling & Logging

Throw typed errors on server; format to JSON with code, message, optional details.

In UI, show user-friendly toasts/dialogs; never expose stack traces.

Centralize logging utilities (lib/logger.ts); no console.* in production paths.

10) Accessibility & i18n

Keyboard navigation must work; focus states visible; role and aria-* correct.

Images and icons require alt/aria-label when meaningful.

If i18n needed, use next-intl or next-i18next; no string literals in components—centralize copy.

11) Env & Config

Typed env: env.mjs with Zod; separate server and client env; access client env via NEXT_PUBLIC_*.

Feature flags/config in config/ and never in component files.

12) Git, PRs, and CI

Branch naming: type/scope-short-desc (e.g., feat/foods-parser).

PRs small and focused; include screenshots for UI changes and Playwright updates if relevant.

CI must run: typecheck, lint, tests, build. No failing PRs can be merged.

Require code review; block self-merge without at least one approval.

13) Dependencies & Tooling

Pin versions with caret; avoid unnecessary deps; prefer std libs and existing utilities.

No global polyfills unless required by Next; tree-shake friendly imports only.

Remove dead code and unused deps promptly.

14) Documentation

Keep README updated with scripts, env vars, and architecture notes (1-pager).

Co-locate feature READMEs (features/<feature>/README.md) for complex domains.

Update CHANGELOG.md on each release (auto-generated acceptable).

15) Cursor Agent Directions (meta)

Prefer Server Components and server data fetching; add "use client" only when interactivity is required.

Before writing new code, search repo for existing utilities/components.

After generating code, run eslint --fix & typecheck, add/adjust tests, and ensure accessibility lints pass.

Do not modify generated shadcn/ui primitives—wrap them.

Keep diffs minimal; avoid drive-by refactors.
